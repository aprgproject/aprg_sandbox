#include "IntegrationGeometryUtilities.hpp"

#include <Algebra/Differentiation/Differentiation.hpp>
#include <Algebra/Integration/Integration.hpp>
#include <Algebra/Term/Operators/TermOperators.hpp>
#include <Algebra/Term/Utilities/TermUtilities.hpp>

using namespace std;

namespace alba
{

namespace algebra
{

Term getAreaInBetweenTwoTermsInAnInterval(
        Term const& lowerTerm,
        Term const& higherTerm,
        string const& variableName,
        AlbaNumber const& lowerValueInInterval,
        AlbaNumber const& higherValueInInterval)
{
    Integration integration(variableName);
    Term difference(higherTerm-lowerTerm);
    return integration.integrateAtDefiniteValues(difference, lowerValueInInterval, higherValueInInterval);
}

Term getVolumeUsingOnCrossSectionalArea(
        Term const& crossSectionalArea,
        string const& variableName,
        Term const& lowerValueTerm,
        Term const& higherValueTerm)
{
    Integration integration(variableName);
    return integration.integrateAtDefiniteTerms(crossSectionalArea, lowerValueTerm, higherValueTerm);
}

Term getVolumeUsingOnSolidOfRevolution(
        Term const& term,
        string const& variableName,
        Term const& lowerValueTerm,
        Term const& higherValueTerm)
{
    // Let the function f be continuous on the closed interval [a, b], and assume that f(x) >= 0 for all x in [a, b].
    // If S is the solid of revolution obtained by revolving about the x axis the region bounded by the curve y=f(x),
    // the x axis and the lines x=a and x=b, and if the V cubic is the volume of S, then

    // The volume is equal to pi times the definite integral of square of f(x) from a to b.
    // This method uses disks.

    Integration integration(variableName);
    Term termToIntegrate = getPiAsTerm()*(term^Term(2));
    return integration.integrateAtDefiniteTerms(termToIntegrate, lowerValueTerm, higherValueTerm);
}

Term getVolumeUsingOnSolidOfRevolution(
        Term const& lowerFunctionTerm,
        Term const& higherFunctionTerm,
        string const& variableName,
        Term const& lowerValueTerm,
        Term const& higherValueTerm)
{
    // Let the functions f and g be continuous on the closed interval [a, b], and assume that f(x) >= g(x) >= 0 for all x in [a, b].
    // If V cubic units is the volume of the solid of revolution generated by revolving about the x axis the region
    // bounded by the curves y=f(x) and y=g(x) and the lines x=a and x=b, then

    // The volume is equal to pi times the definite integral of square of (f(x)-g(x)) from a to b.
    // This method uses washers(disks with holes).

    Integration integration(variableName);
    Term termToIntegrate = getPiAsTerm()*((higherFunctionTerm-lowerFunctionTerm)^Term(2));
    return integration.integrateAtDefiniteTerms(termToIntegrate, lowerValueTerm, higherValueTerm);
}

Term getVolumeUsingCylindricalShells(
        Term const& term,
        string const& variableName,
        Term const& lowerValueTerm,
        Term const& higherValueTerm)
{
    // Let the function f be continuous on the closed interval [a, b], where a>=0.
    // Assume that f(x) >= 0 for all x in [a, b].
    // If R is the region bounded by the curve y=f(x), the x axis and the lines x=a and x=b,
    // if S is the solid of revolution obtained by revolving R about the y axis, and if V cubic units is the volume of S, then

    // The volume is equal to 2*pi times the definite integral of x times f(x) from a to b.
    // This method uses cylindrical shells (like a can without the top and bottom)

    Integration integration(variableName);
    Term termToIntegrate = Term(2)*getPiAsTerm()*(Term(variableName)*term);
    return integration.integrateAtDefiniteTerms(termToIntegrate, lowerValueTerm, higherValueTerm);
}

Term getLengthOfArc(
        Term const& term,
        string const& variableName,
        Term const& lowerValueTerm,        Term const& higherValueTerm)
{
    // If the function f and its derivative fPrime are continuous on the closed interval [a, b],
    // then the length of arc of the curve y=f(x) from the point (a, f(a) to the point (b, f(b)) is given by:
    // The length is equal to the the definite integral of the square root of (1+fPrime^2) from a to b.

    Differentiation differentiation(variableName);
    Integration integration(variableName);
    Term differentiatedTerm(differentiation.differentiate(term));
    Term termToIntegrate = (Term(1)+(differentiatedTerm^Term(2)))^Term(AlbaNumber::createFraction(1, 2));
    termToIntegrate.simplify();
    return integration.integrateAtDefiniteTerms(termToIntegrate, lowerValueTerm, higherValueTerm);
}

Term getLengthOfArcInPolarCoordinates(
        Term const& radiusInTermsOfTheta,
        std::string const& thetaName,
        Term const& lowerValueTermInTheta,
        Term const& higherValueTermInTheta)
{
    Differentiation differentiation(thetaName);
    Integration integration(thetaName);
    Term drOverDTheta(differentiation.differentiate(radiusInTermsOfTheta));
    Term termToIntegrate = ((drOverDTheta^Term(2))+(radiusInTermsOfTheta^Term(2)))^Term(AlbaNumber::createFraction(1, 2));
    termToIntegrate.simplify();
    return integration.integrateAtDefiniteTerms(termToIntegrate, lowerValueTermInTheta, higherValueTermInTheta);
}

Term getTotalMassOfARod(
        Term const& term,
        string const& variableName,        Term const& lowerValueTerm,
        Term const& higherValueTerm)
{
    // A rod of length L meters has its left endpoint at the origin.    // If p(x) kilograms per meter is the linear density at a point x meters from the origin, where p is continuous on [0, L], then:

    // The total mass of the rod is the definite integral of p(x) from 0 to L.

    Integration integration(variableName);
    return integration.integrateAtDefiniteTerms(term, lowerValueTerm, higherValueTerm);
}

Term getMomentOfMassOfARod(
        Term const& term,
        string const& variableName,
        Term const& lowerValueTerm,
        Term const& higherValueTerm)
{
    // A rod of length L meters its left endpoint at the origin and p(x) kilograms per meter is the linear density at a point x meters from the origin,
    // where p is continuous on [0, L].

    // The moment of mass of the rod is the definite integral of x*p(x) from 0 to L.

    Integration integration(variableName);
    Term termToIntegrate = Term(variableName)*term;
    return integration.integrateAtDefiniteTerms(termToIntegrate, lowerValueTerm, higherValueTerm);
}

Term getCenterOfMassOfARod(
        Term const& term,
        string const& variableName,
        Term const& lowerValueTerm,
        Term const& higherValueTerm)
{
    return getMomentOfMassOfARod(term, variableName, lowerValueTerm, higherValueTerm)
            / getTotalMassOfARod(term, variableName, lowerValueTerm, higherValueTerm);
}

Term getTotalMassOfALamina(
        Term const& term,
        string const& variableName,
        Term const& lowerValueTerm,
        Term const& higherValueTerm)
{
    Integration integration(variableName);
    return integration.integrateAtDefiniteTerms(term, lowerValueTerm, higherValueTerm);
}

TermPair getMomentOfMassOfALamina(
        Term const& term,
        string const& variableName,
        Term const& lowerValueTerm,
        Term const& higherValueTerm)
{
    Integration integration(variableName);
    Term termToIntegrateInX = Term(AlbaNumber::createFraction(1, 2)) * Term(term^2);
    Term termToIntegrateInY = Term(variableName) * Term(term);
    TermPair xyPair;
    xyPair.first = integration.integrateAtDefiniteTerms(termToIntegrateInX, lowerValueTerm, higherValueTerm);
    xyPair.second = integration.integrateAtDefiniteTerms(termToIntegrateInY, lowerValueTerm, higherValueTerm);
    return xyPair;
}

TermPair getCenterOfMassOfALamina(
        Term const& term,
        string const& variableName,
        Term const& lowerValueTerm,
        Term const& higherValueTerm)
{
    Term totalMass(getTotalMassOfALamina(term, variableName, lowerValueTerm, higherValueTerm));
    TermPair xyPair(getMomentOfMassOfALamina(term, variableName, lowerValueTerm, higherValueTerm));
    xyPair.first = xyPair.first/totalMass;
    xyPair.second = xyPair.second/totalMass;
    return xyPair;
}

TermPair getCentroid(
        Term const& term,
        string const& variableName,
        Term const& lowerValueTerm,
        Term const& higherValueTerm)
{
    Integration integration(variableName);
    Term area(integration.integrateAtDefiniteTerms(term, lowerValueTerm, higherValueTerm));
    TermPair xyPair(getMomentOfMassOfALamina(term, variableName, lowerValueTerm, higherValueTerm));
    xyPair.first = xyPair.first / area;
    xyPair.second = xyPair.second / area;
    return xyPair;
}

Term getWork(
        Term const& force,
        string const& variableName,
        Term const& lowerValueTerm,
        Term const& higherValueTerm)
{
    Integration integration(variableName);
    return integration.integrateAtDefiniteTerms(force, lowerValueTerm, higherValueTerm);
}

Term getLiquidPressure(
        Term const& massDensity,
        Term const& accelerationDueToGravity,
        Term const& length,
        string const& depth,
        Term const& lowerValueTerm,
        Term const& higherValueTerm)
{
    Integration integration(depth);
    Term termToIntegrate = massDensity*accelerationDueToGravity*Term(depth)*length;
    return integration.integrateAtDefiniteTerms(termToIntegrate, lowerValueTerm, higherValueTerm);
}

Term integrateInPolarCoordinates(
        Term const& radiusInTermsOfTheta,
        string const& thetaName,
        Term const& lowerValueTermInTheta,
        Term const& higherValueTermInTheta)
{
    Integration integration(thetaName);
    Term radiusSquared(radiusInTermsOfTheta^2);
    radiusSquared.simplify();
    return integration.integrateAtDefiniteTerms(radiusSquared, lowerValueTermInTheta, higherValueTermInTheta);
}

}
}